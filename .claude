# Claude Code Instructions


### Analyzer Structure
@Project overview.md - Examples

### Test Structure
Each analyzer has TWO types of tests:

#### 1. Unit/Business Logic Tests (`analyzers/tests/analyzer-name.test.ts`)
- Test business functionality
- Test helper methods
- Test data parsing logic
- Test edge cases
- **MOCK DATA ALLOWED** for API calls only
- Focus on testing logic, not external dependencies

#### 2. Integration Tests (`playground/analyzer-name.test.ts`)
- Test with real files
- Make real API calls
- **ABSOLUTELY NO MOCK DATA**
- Test end-to-end functionality
- Verify actual API responses
- Real file reading, real network calls
- Simple to read output from test, no aggregating unless asked

### Coding Standards

**Follow the coding standards and examples defined in `{languange}-standards-examples.md`** example typescript-standards-examples.md

### Key Rules
1. **Follow {languange}-standards-examples.md** for all coding patterns
2. **Mock data allowed in analyzers/tests/** - for unit testing business logic
3. **NO mock data in playground/** - real files, real API calls only

### Test Organization
- **analyzers/tests/**: Unit tests with mocked dependencies for fast, reliable testing
- **playground/**: Integration tests with real dependencies for end-to-end validation

### Standards Reference
All TypeScript code must follow the patterns and examples in `typescript-standards-examples.md`. This includes:
- Async/await with proper error handling
- Type-safe API calls
- Discriminated unions for result types
- Proper use of generics and utility types
- Immutability with readonly where appropriate

This structure ensures maintainability, testability, and simplicity while meeting all project requirements.

## Project Documentation

### ðŸ“š Documentation Files
Please review these documentation files before starting any work:

- **[CLAUDE.md](./CLAUDE.md)** - This file - Project instructions and coding standards
- **[development-plan.md](./development-plan.md)** - Project roadmap, current status, and completed features
- **[{languane}-standards-examples.md](example ./typescript-standards-examples.md)** - coding patterns and examples

## Project Documentation

### ðŸ“š Documentation Files
Please review these documentation files before starting any work:

- **[CLAUDE.md](./CLAUDE.md)** - This file - Project instructions and coding standards
- **[development-plan.md](./development-plan.md)** - Project roadmap, current status, and completed features
- **[{languane}-standards-examples.md](example ./typescript-standards-examples.md)** - coding patterns and examples

### ðŸ“‹ Development Plan Management

**IMPORTANT**: You MUST update the development plan after completing each task, feature or step:

1. **Review the development plan** at the start of each session by reading `development-plan.md`
2. **Update progress markers** - Change `[ ]` to `[x]` for completed items
3. **Update the Current Status section** with:
   - New completed features
   - Current metrics and results
   - Any architectural changes
4. **Add new tasks** to the appropriate phase as they are discovered
5. **Update file structure** if new files are created or moved
6. IF anything in the development plan conflicts ASK for clarification

This ensures the development plan stays current and provides accurate project status for future sessions.

### ðŸ”§ How to Add Detailed Tasks to Development Plan

When adding new tasks to the development plan, use this structured approach for maximum clarity:

#### **Format Template:**
```markdown
- [ ] **Component Name** - Brief description (1-2 words) of what this component does
  - [ ] `functionName(input: Type) -> OutputType` - What this function does
  - [ ] `anotherFunction(input: Type) -> OutputType` - What this function does
  - [ ] `helperFunction(input: Type) -> OutputType` - What this function does
  - [ ] **Types needed:** `ComponentResult`, `InputType`, `ConfigType`
  - [ ] **Tests:** Unit tests + Integration tests
```

#### **Generic Example (Language Agnostic):**
```markdown
- [ ] **Data Validator** - Validates input data against business rules
  - [ ] `validateRequired(data: Object) -> ValidationResult` - Check required fields exist
  - [ ] `validateTypes(data: Object, schema: Schema) -> ValidationResult` - Type validation
  - [ ] `validateBusiness(data: Object, rules: Rules) -> ValidationResult` - Business rule checks
  - [ ] `formatErrors(errors: ErrorList) -> FormattedOutput` - Format validation errors
  - [ ] **Types needed:** `ValidationResult`, `Schema`, `Rules`, `ErrorList`
  - [ ] **Tests:** Unit tests with mock data + Integration tests with real data
```

#### **Real Project Example (TypeScript):**
```markdown
- [ ] **Forked Library Analyzer** - Detects dependencies that are forked versions of originals
  - [ ] `detectForks(sbom: SBOM) -> ForkResult[]` - Identify potential forks from SBOM data
  - [ ] `fetchOriginalRepo(packageUrl: string) -> RepoInfo | null` - Find original repository
  - [ ] `compareForkToOriginal(fork: RepoInfo, original: RepoInfo) -> ForkComparison` - Compare fork vs original
  - [ ] `assessMaintenanceRisk(comparison: ForkComparison) -> RiskLevel` - Calculate maintenance risk
  - [ ] `generateForkReport(results: ForkResult[]) -> ForkReport` - Create structured output
  - [ ] **Types needed:** `ForkResult`, `RepoInfo`, `ForkComparison`, `RiskLevel`, `ForkReport`
  - [ ] **Tests:** Unit tests with mocked APIs + Integration tests with real repositories
```

#### **Key Principles:**
1. **Start with high-level purpose** - One sentence describing what the component does
2. **Break into specific functions** - Each function should have a single responsibility
3. **Define clear inputs/outputs** - Use proper type annotations
4. **List required types** - All interfaces and types the component needs
5. **Plan testing strategy** - Both unit and integration test approaches
6. **Use consistent naming** - Function names should be verbs, types should be nouns
7. **Follow language standards** - Always refer to `{language}-standards-examples.md` for syntax and patterns (e.g., `typescript-standards-examples.md`, `elixir-standards-examples.md`, etc.)
8. **Keep it simple**: Code should be understandable by a junior engineer
9. **Be pragmatic**: Don't over-engineer, solve the problem directly
10. **No unnecessary complexity**: Parse JSON directly, avoid abstractions
11.  **Real data in playground**: No mock data in playground tests



## Project Structure & Standards

#### **Key Principles:**
1. **Start with high-level purpose** - One sentence describing what the component does
2. **Break into specific functions** - Each function should have a single responsibility
3. **Define clear inputs/outputs** - Use proper type annotations
4. **List required types** - All interfaces and types the component needs
5. **Plan testing strategy** - Both unit and integration test approaches
6. **Use consistent naming** - Function names should be verbs, types should be nouns
7. **Follow language standards** - Always refer to `{language}-standards-examples.md` for syntax and patterns (e.g., `typescript-standards-examples.md`, `elixir-standards-examples.md`, etc.)
8. **Keep it simple**: Code should be understandable by a junior engineer
9. **Be pragmatic**: Don't over-engineer, solve the problem directly
10. **No unnecessary complexity**: Parse JSON directly, avoid abstractions
11.  **Real data in playground**: No mock data in playground tests
